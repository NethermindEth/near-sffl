"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[65],{4692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=n(4848),s=n(8453);const r={sidebar_position:4},a="Operator Set Tracking",o={id:"design/operator_set_tracking",title:"Operator Set Tracking",description:"Please refer to Overview for an introduction.",source:"@site/docs/design/operator_set_tracking.md",sourceDirName:"design",slug:"/design/operator_set_tracking",permalink:"/near-sffl/design/operator_set_tracking",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"sidebar",previous:{title:"Network Management",permalink:"/near-sffl/design/network_management"},next:{title:"Faults",permalink:"/near-sffl/design/faults"}},c={},d=[{value:"Updates",id:"updates",level:2},{value:"Syncing",id:"syncing",level:2},{value:"Operator Entry/Exit Queue",id:"operator-entryexit-queue",level:3},{value:"Changing the Signature Architecture to ECDSA",id:"changing-the-signature-architecture-to-ecdsa",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"operator-set-tracking",children:"Operator Set Tracking"}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["Please refer to ",(0,i.jsx)(t.a,{href:"/near-sffl/design/overview",children:"Overview"})," for an introduction."]})}),"\n",(0,i.jsx)(t.h2,{id:"updates",children:"Updates"}),"\n",(0,i.jsx)(t.p,{children:"Operator set updates are block-based changes in the operator set which are used\nby the AVS operators in order to update networks' operator sets through an\nattestation."}),"\n",(0,i.jsx)(t.p,{children:"An operator set update is comprised of all the updates in operator weights in\none block, and as such happens at most once a block. It also has an\nincrementing ID - which is then used on the attestation message and that can be\nused to fetch the update content for verifying evidences on bad messages."}),"\n",(0,i.jsxs)(t.p,{children:["This design and tracking logic is mostly implemented on the\n",(0,i.jsx)(t.code,{children:"SFFLOperatorSetUpdateRegistry"})," contract."]}),"\n",(0,i.jsx)(t.h2,{id:"syncing",children:"Syncing"}),"\n",(0,i.jsx)(t.p,{children:"The goal of standardizing and attesting operator set updates is to make it\npossible that each participating network has a copy of the operator set locally\nso it can verify attestations."}),"\n",(0,i.jsx)(t.p,{children:"However, as this is essentially bridging data from Ethereum to other networks,\nit's indeed not guaranteed that the operator sets will always match. Even if\nthe Aggregator relays all operator set update attestations in time, there will\nstill be a time range in which the operator set has been updated on Ethereum\nbut the change was not yet taken into account in one or more participating\nnetworks."}),"\n",(0,i.jsx)(t.p,{children:"This is especially problematic for verifying attestations, as a different\noperator set may lead to the attestation, which is based on an aggregated\nsignature that used the current operator set as reference, not being\nverifiable. This could happen both when the attestation is based on the current\noperator set, in which case it should be verifiable in a short time, and also\nwhen it's based on a previous operator set, which means it's likely simply not\nverifiable and the user would need to get a current attestation."}),"\n",(0,i.jsx)(t.p,{children:"There are two planned approaches to mitigate this issue: adding an entry/exit\nqueue to the operator set and changing the signature architecture to ECDSA."}),"\n",(0,i.jsx)(t.h3,{id:"operator-entryexit-queue",children:"Operator Entry/Exit Queue"}),"\n",(0,i.jsx)(t.p,{children:"An entry/exit queue would limit the effective operator set updates to a fixed\nfrequency. This would not only make it so secondary networks need to be\nupdated less often but also that the case in which messages would not be\nverifiable for a short period of time would happen more rarely."}),"\n",(0,i.jsx)(t.p,{children:"An addition to this, as the frequency would be pre-determined, could be storing\na fixed number the past operator sets instead of only the current operator set\nin the secondary networks. This way, messages from the previous operator sets\nwould still be verifiable and the UX could be greatly improved in case of late\ntransactions or such."}),"\n",(0,i.jsx)(t.h3,{id:"changing-the-signature-architecture-to-ecdsa",children:"Changing the Signature Architecture to ECDSA"}),"\n",(0,i.jsxs)(t.p,{children:["The default signature architecture for AVSs is BLS, simply because it makes\nverifying multiple signatures a lot easier by aggregating them. This way,\ninstead of N signatures, there's actually only one, in the best case. More\nspecifically, the scaling turns from ",(0,i.jsx)(t.code,{children:"O(n)"})," to ",(0,i.jsx)(t.code,{children:"O(m)"}),", in which ",(0,i.jsx)(t.code,{children:"n"})," is the\nnumber of signers and ",(0,i.jsx)(t.code,{children:"m"})," is the number of non-signers."]}),"\n",(0,i.jsx)(t.p,{children:"Consequently, whenever a BLS aggregation needs to be checked for quorum, it\nshould include the aggregated public key and signature, and also the\nnon-signers."}),"\n",(0,i.jsx)(t.p,{children:"The problem with this is that it effectively makes it so the operator set can\nonly be exactly the expected one - if the current operator set aggregated\npublic key subtracted by the non-signers public keys does not match the message\nsigners aggregated public key, then the message is not verifiable. If keeping\ntrack of signers was an option, a message from a previous operator set would\nstill be verifiable if at the current point it has enough quorum."}),"\n",(0,i.jsx)(t.p,{children:"Still, keeping track of signers makes it so there's not much of a benefit in\nusing BLS over ECDSA. So, in this case, moving to ECDSA would lead to some\nbenefits, and the only immediate tradeoff is the feasible operator set size.\nSince, in liveness terms, the operator set size must be limited, it should be\nrealistic to move to ECDSA as soon as EigenLayer offers support for it in their\nmiddleware contracts."})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(6540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);