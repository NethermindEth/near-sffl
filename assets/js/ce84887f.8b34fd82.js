"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[100],{5789:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var o=n(4848),r=n(8453);const s={sidebar_position:3},a="Network Management",i={id:"design/network_management",title:"Network Management",description:"Please refer to Overview for an introduction.",source:"@site/docs/design/network_management.md",sourceDirName:"design",slug:"/design/network_management",permalink:"/design/network_management",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"sidebar",previous:{title:"Messaging and Checkpoints",permalink:"/design/messaging_and_checkpoints"},next:{title:"Operator Set Tracking",permalink:"/design/operator_set_tracking"}},l={},c=[{value:"Support",id:"support",level:2},{value:"Dynamic Changes",id:"dynamic-changes",level:2},{value:"Heterogenous Support",id:"heterogenous-support",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"network-management",children:"Network Management"}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["Please refer to ",(0,o.jsx)(t.a,{href:"/design/overview",children:"Overview"})," for an introduction."]})}),"\n",(0,o.jsx)(t.p,{children:"The SFFL manages a network set, and a number of processes are actually\nrelated to the network set - be it in terms of the number of networks and also\nthe specifics of each network."}),"\n",(0,o.jsx)(t.p,{children:"Most of the points below are to be tackled in future works."}),"\n",(0,o.jsx)(t.h2,{id:"support",children:"Support"}),"\n",(0,o.jsx)(t.p,{children:"In terms of the current design, only EVM rollups are supported as participant\nnetworks. There are some reasons for that."}),"\n",(0,o.jsx)(t.p,{children:"First of all, we need state roots to be verifiable on Ethereum somehow. In\nterms of rollups, that's a feasible task, as the network data is periodically\nposted there. In terms of other networks, it may vary considerably. In the case\nthe network has an Ethereum light client, it should be viable to add it."}),"\n",(0,o.jsxs)(t.p,{children:["However, in terms of non-EVM chains, there's another challenge - as the state\nverification process should be essentially different, it's necessary to\nintegrate it in the SFFL contracts and, depending on the network, potentially\nadapt the ",(0,o.jsx)(t.code,{children:"StateRootUpdateMessage"})," format."]}),"\n",(0,o.jsx)(t.h2,{id:"dynamic-changes",children:"Dynamic Changes"}),"\n",(0,o.jsx)(t.p,{children:"One more related challenge is dynamic changes to the network set. The current\ndesign only supports a static network set, and any changes require a new setup.\nThis is not ideal and should be tackled soon."}),"\n",(0,o.jsx)(t.p,{children:"Nevertheless, supporting dynamic changes to the network set is not trivial -\nbasically all SFFL actors are related to the network set somehow. In terms of\nthe operators, most importantly, it's expected they'd be running a full node\nfor each network, so it's potentially not a totally automatic operation."}),"\n",(0,o.jsx)(t.h2,{id:"heterogenous-support",children:"Heterogenous Support"}),"\n",(0,o.jsx)(t.p,{children:"Currently, all AVS nodes are uniform - i.e. support the same network set.\nA considerable improvement would be making it so each AVS operator could\nselect the networks to be supported, which is actually really relevant for an\noperator's risk management."}),"\n",(0,o.jsx)(t.p,{children:"This could be done through either a full heterogenous support in the AVS itself\nor through a simplification of the AVS design to support only one network - in\nthis case, there would be one AVS per network."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(6540);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);