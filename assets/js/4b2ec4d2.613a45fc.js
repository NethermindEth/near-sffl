"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[849],{2494:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=n(4848),a=n(8453);const i={sidebar_position:1},r="Overview",o={id:"design/overview",title:"Overview",description:"The NEAR Super Fast Finality Layer (SFFL) aims to provide a fast settlement",source:"@site/docs/design/overview.md",sourceDirName:"design",slug:"/design/overview",permalink:"/design/overview",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"sidebar",previous:{title:"Protocol Design",permalink:"/category/protocol-design"},next:{title:"Messaging and Checkpoints",permalink:"/design/messaging_and_checkpoints"}},h={},c=[{value:"Architecture",id:"architecture",level:2},{value:"Ethereum",id:"ethereum",level:3},{value:"NEAR Data Posting",id:"near-data-posting",level:3},{value:"Off-chain SFFL",id:"off-chain-sffl",level:3},{value:"Network Registry",id:"network-registry",level:3},{value:"Checkpoint Tasks",id:"checkpoint-tasks",level:3},{value:"User Flow",id:"user-flow",level:3}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"The NEAR Super Fast Finality Layer (SFFL) aims to provide a fast settlement\nlayer that allows participating networks to quickly access information from\nother networks in a safe way."}),"\n",(0,s.jsxs)(t.p,{children:["In order to achieve this, SFFL leverages both ",(0,s.jsx)(t.a,{href:"https://near.org",children:"NEAR"})," and\n",(0,s.jsx)(t.a,{href:"https://www.eigenlayer.xyz",children:"EigenLayer"}),", providing not only a way for\nprotocols to provide interoperability features by verifying state attestations\nsecured by restaked ETH but also an intermediate DA layer that increases the\noverall network security for participating networks."]}),"\n",(0,s.jsxs)(t.p,{children:["The architecture is comprised of two off-chain actors, the ",(0,s.jsx)(t.em,{children:"Operators"})," and the\n",(0,s.jsx)(t.em,{children:"Aggregator"}),", which are effectively the AVS nodes, and multiple on-chain\nactors:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"in Ethereum Mainnet, there's the SFFL AVS contract set, which interacts\ndirectly with EigenLayer's."}),"\n",(0,s.jsx)(t.li,{children:"in participating networks, there are SFFL verifier contracts to check\nnetwork state attestations."}),"\n",(0,s.jsx)(t.li,{children:"in NEAR, there is a NEAR DA contract for each participating network which\nserves as a medium for storing historical block data."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsxs)(t.p,{children:["Below is a diagram representation of SFFL's architecture. Let's consider, as an\nexample, ",(0,s.jsx)(t.code,{children:"HelloProtocol"}),", a very primitive protocol in which users want to send\nand receive ",(0,s.jsx)(t.em,{children:"hello"})," from one network to another. In abstract terms, this is the\nbase feature of every bridging protocol. It's a good idea to refer to this\ndiagram whenever any of the interactions seems unclear."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Full Architecture Overview",src:n(7377).A+"",width:"5442",height:"3418"})}),"\n",(0,s.jsx)(t.h3,{id:"ethereum",children:"Ethereum"}),"\n",(0,s.jsxs)(t.p,{children:["First of all, SFFL's functionality comes from an AVS, that is, an EigenLayer\n",(0,s.jsx)(t.em,{children:"Actively Validated Service"}),", which is a system that requires a specific\nvalidation through a distributed network which is, in turn, registered and\nspecified in terms of EigenLayer's restaking capabilities."]}),"\n",(0,s.jsxs)(t.p,{children:["This means the SFFL architecture actually starts on Ethereum, as the ",(0,s.jsx)(t.a,{href:"https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/docs",children:"EigenLayer\ncore contracts"}),"\nlive there. So, in order for SFFL to have economic security, users must first\nrestake ETH into EigenLayer, becoming ",(0,s.jsx)(t.em,{children:"Restakers"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The SFFL has a set of smart contracts which, in EigenLayer terms, are called\n",(0,s.jsx)(t.em,{children:"middleware"}),", which are directly connected to the EigenLayer core contracts.\nThrough this, as an AVS, various data and operations are available and SFFL\noperations such as registering as an ",(0,s.jsx)(t.em,{children:"Operator"})," (a validator) and validating\ntask resolutions (more on that later) can be implemented. ",(0,s.jsx)(t.em,{children:"Restakers"})," can\neither become or delegate their restaked balance to ",(0,s.jsx)(t.em,{children:"Operators"}),", which will\nthen validate the AVS on their behalf."]}),"\n",(0,s.jsx)(t.h3,{id:"near-data-posting",children:"NEAR Data Posting"}),"\n",(0,s.jsxs)(t.p,{children:["The SFFL is comprised of multiple participating networks. These networks take\npart in SFFL to achieve a faster 'finality' for chain interoperability\npurposes. In order to do that, it must contain an entity called a ",(0,s.jsx)(t.em,{children:"Relayer"}),".\nThis Relayer constantly posts block data to NEAR DA, providing a fast and\npublic ledger to the current network state."]}),"\n",(0,s.jsx)(t.p,{children:"In order to do that, each network should have a NEAR DA contract. This contract\nis then called by the Relayer for submitting arbitrary data, in this case,\nexclusively block data."}),"\n",(0,s.jsxs)(t.p,{children:["The data posted to NEAR through the DA contracts will then be indexed by the\nAVS operators, which will then double-check the posted blocks with their own\nfull nodes' data and agree on the network state. This means that even if the\n",(0,s.jsx)(t.em,{children:"Relayer"})," acts maliciously, this doesn't mean the AVS will necessarily agree\nwith it."]}),"\n",(0,s.jsx)(t.p,{children:"There's an example Relayer implementation, but it should slightly change\ndepending on the specific network and stack, as it should ideally be\nintegrated into a node."}),"\n",(0,s.jsx)(t.h3,{id:"off-chain-sffl",children:"Off-chain SFFL"}),"\n",(0,s.jsx)(t.p,{children:"As can be seen in the diagram and usual for an AVS, the SFFL is not\nexclusively based on smart contracts. Actually, the attestation work is\nperformed by an off-chain network of Operators which are linked to an\nAggregator."}),"\n",(0,s.jsx)(t.p,{children:"An SFFL Operator, besides the actual operator node, runs a full node for each\nof the participant networks (including Ethereum), as well as a NEAR full node\nand a NEAR DA indexer. Their simplified flow can be described through the\nfollowing:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"The indexer captures a block posted to NEAR DA for one of the networks and\nsends it to the operator node."}),"\n",(0,s.jsx)(t.li,{children:"The operator node retrieves and parses the block."}),"\n",(0,s.jsxs)(t.li,{children:["The operator node checks the block is the same as the one in their\nself-hosted network full node.","\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"If the blocks do not match, the ultimate source of truth is the full\nnode."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.li,{children:"The operator node, through their BLS keypair, signs a message attesting\nthat for the network in question in that block height, the state root is the\none that was fetched."}),"\n",(0,s.jsx)(t.li,{children:"The operator sends the signed message to the Aggregator."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The Aggregator, then, collects BLS signatures from multiple operators. Whenever\na desired quorum is reached in terms of operator power (i.e. restaked amount),\nall of the signatures are aggregated into one and made available through an\nAPI."}),"\n",(0,s.jsxs)(t.p,{children:['This aggregated signature, when validated by a program that has access to the\noperator set, is the equivalent of "',(0,s.jsxs)(t.em,{children:["A sufficient amount of operators has agreed\nthat, for network ",(0,s.jsx)(t.code,{children:"N"}),", at block height ",(0,s.jsx)(t.code,{children:"H"}),", the state root is ",(0,s.jsx)(t.code,{children:"S"})]}),"\". And that's\nexactly what we want - so, with this, allowing cross-chain state access is\nsimply verifying these attestations!"]}),"\n",(0,s.jsxs)(t.p,{children:["Operators also track operator set updates on the AVS contracts and emit\nattestations for those in a somehow similar process - instead of expecting\nblock data externally, it simply subscribes to Ethereum updates through its\nfull node. The importance of that will be discussed in\n",(0,s.jsx)(t.a,{href:"#network-registry",children:"Network Registry"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For more details on the messaging flow, please check\n",(0,s.jsx)(t.a,{href:"/design/messaging_and_checkpoints",children:"Messaging and Checkpoints"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"network-registry",children:"Network Registry"}),"\n",(0,s.jsxs)(t.p,{children:["The vital part of the participant network environment is the ",(0,s.jsx)(t.em,{children:"Registry"}),"\ncontract. This contract, which should be deployed on each of the participating\nnetworks, should effectively be used to verify the attestations that were\ndiscussed above."]}),"\n",(0,s.jsx)(t.p,{children:"In order to do that, these contracts should have access to the AVS operator\nset - otherwise, it can't know if a signer is an operator or not, much less\nwhether the attestation has passed quorum or not."}),"\n",(0,s.jsx)(t.p,{children:"So, actually SFFL Registry contracts have two roles - they keep a copy of the\noperator set and they validate attestations. In order to keep this operator set\nup to date, as it's not always true that it can access Ethereum's state\nsomehow, it relies on other attestations - in this case, not for state root\nupdates, but actually for operator set updates."}),"\n",(0,s.jsx)(t.p,{children:"What this means is that this operator set relies on the AVS attestations to be\nup-to-date - the AVS operators themselves agree on each operator set delta.\nThis is an easily verifiable 'task' in terms of slashing, and implements the\ncross-chain messaging necessary for communicating this from Ethereum to the\nother participant networks."}),"\n",(0,s.jsx)(t.p,{children:"In terms of operator set update submission, this would be an Aggregator task\nby default, but it would not be restricted to it - any user could also submit\nit. Changes on this, especially in terms of economic incentives, are planned."}),"\n",(0,s.jsx)(t.h3,{id:"checkpoint-tasks",children:"Checkpoint Tasks"}),"\n",(0,s.jsxs)(t.p,{children:["As defined in various AVS guidelines, such as\n",(0,s.jsx)(t.a,{href:"https://docs.eigenlayer.xyz/eigenlayer/avs-guides/first-steps-towards-designing-an-avs",children:"this one"}),",\nan AVSs operation should be understandable in terms of units of work called\n",(0,s.jsx)(t.em,{children:"Tasks"}),". These tasks are defined in the AVS contracts on Ethereum, and are\ndirectly related to slashing and payment flows."]}),"\n",(0,s.jsxs)(t.p,{children:["However, in terms of the SFFL, each of the attestations above is not defined\nas a ",(0,s.jsx)(t.em,{children:"Task"})," - rather, it's defined as a ",(0,s.jsx)(t.em,{children:"Message"}),". As such, the ",(0,s.jsx)(t.em,{children:"Task"})," that\ndefines the SFFL is not any of those, but it's actually ",(0,s.jsx)(t.em,{children:"all of those"})," - more\nspecifically, the unit of work required from all validators is to attest on\nthe aggregation (more specifically ",(0,s.jsx)(t.em,{children:"Merkleization"}),") of messages in a time\nrange."]}),"\n",(0,s.jsx)(t.p,{children:"This way, the existance or non-existance of a message in a time range can be\nlater on checked on Ethereum through the task response. This is meant to be\nused for slashing and payment purposes."}),"\n",(0,s.jsxs)(t.p,{children:["For more details on checkpoints, refer to\n",(0,s.jsx)(t.a,{href:"/design/messaging_and_checkpoints",children:"Messaging and Checkpoints"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"user-flow",children:"User Flow"}),"\n",(0,s.jsx)(t.p,{children:"Finally - how can SFFL be used by a user or protocol? The integration is\nactually quite simple. Let's follow the HelloProtocol example: consider a user\nhad sent a \"hello!\" message on Network #2 to Network #1, recording it on\nNetwork #2's state."}),"\n",(0,s.jsx)(t.p,{children:"Eventually, the block in which the message was submitted gets considered in\nSFFL and a state root attestation was collected for the Network #2's state.\nThrough it, anyone can submit the attestation to any network, not only Network\n#1, making Network #2's state available on it."}),"\n",(0,s.jsx)(t.p,{children:"The HelloProtocol (off-chain) app would then keep track of SFFL's state and,\nas such, would be able to fetch this attestation as soon as it's available.\nThis complexity can be simply abstracted from the user."}),"\n",(0,s.jsx)(t.p,{children:'When the attestation is done, the protocol lets the user consume the "hello!"\non Network #1 by sumbitting a transaction that indicates the storage proof\nof the message on Network #2 and the attestation from SFFL. Again, the UX is\nnot really impacted - the proof should also be generated in the background.'}),"\n",(0,s.jsx)(t.p,{children:'This data is then relayed by the HelloProtocol contract to the SFFL Registry\ncontract, which validates the attestation and checks the storage proof - and\nthere is our "hello!"!'}),"\n",(0,s.jsx)(t.p,{children:"In easier terms, in UX terms, all of the parts of this integration that, to\nthe user, may seem strange, can be simply abstracted from them. In\nimplementation terms, it's a matter of fetching the attestation and the proof,\nas well as linking the protocol's contracts to SFFL's and relaying the fetched\ndata."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},7377:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/full_architecture_overview-e30dd2652c193e94877b623740234938.svg"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);