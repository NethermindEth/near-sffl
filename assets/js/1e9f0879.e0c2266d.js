"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[860],{6135:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var t=s(4848),a=s(8453);const i={sidebar_position:2},o="Messaging and Checkpoints",r={id:"design/messaging_and_checkpoints",title:"Messaging and Checkpoints",description:"Please refer to Overview for an introduction.",source:"@site/docs/design/messaging_and_checkpoints.md",sourceDirName:"design",slug:"/design/messaging_and_checkpoints",permalink:"/near-sffl/design/messaging_and_checkpoints",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"sidebar",previous:{title:"Overview",permalink:"/near-sffl/design/overview"},next:{title:"Network Management",permalink:"/near-sffl/design/network_management"}},d={},l=[{value:"Terminology",id:"terminology",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Checkpoint Task",id:"checkpoint-task",level:2},{value:"SFFL Messages",id:"sffl-messages",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"messaging-and-checkpoints",children:"Messaging and Checkpoints"}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Please refer to ",(0,t.jsx)(n.a,{href:"/near-sffl/design/overview",children:"Overview"})," for an introduction."]})}),"\n",(0,t.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsxs)(n.p,{children:["As mentioned, there are two types of units of work that SFFL Operators must\ncomplete: ",(0,t.jsx)(n.em,{children:"Messages"})," and ",(0,t.jsx)(n.em,{children:"Tasks"}),". This terminology was developed to make clear\nthat those are two mostly different things, and, more importantly, it's\nsomething specific of how SFFL works as opposed to the general AVS design."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Messages"})," are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Generated directly from the operators: distributed, there's no such thing as\na message creator"}),"\n",(0,t.jsx)(n.li,{children:"Essentially off-chain: as they are meant for potentially high throughput,\nit's not cost and speed-effective to store them all individually on-chain"}),"\n",(0,t.jsx)(n.li,{children:"Verified on demand: messages are not always verified on-chain - they should\nbe available for verification at all times, but it's not necessary that the\nattestation (response) is submitted on-chain"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Tasks"})," are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Generated by a ",(0,t.jsx)(n.em,{children:"Task Manager"}),": an entity must determine the work that should\nbe done and expect an answer from the operators"]}),"\n",(0,t.jsx)(n.li,{children:"On-chain: Tasks are stored directly on the AVS contracts, and a response is\nexpected to be submitted on-chain in a certain time range"}),"\n",(0,t.jsx)(n.li,{children:"Always verified: task responses should always be verified on-chain, as a\nfailure in doing so would lead to a direct liveness evidence on-chain"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(n.p,{children:"Now that the terminology is defined, we need to discuss why this has been\ndesigned in the first place."}),"\n",(0,t.jsx)(n.p,{children:"EigenLayer's implementation of a Task is really similar to the definition\nabove, and it's defined, in design terms, that the Task should indeed be the\nAVS unit of work. This is totally understandable, as the characteristics above\nmake it so the payment and slashing flow are quite straight-forward."}),"\n",(0,t.jsxs)(n.p,{children:["However, this would not be enough for SFFL's functionalities. The main usage of\nthe AVS agreement is agreeing on state root updates - i.e. block based\nprogression of each participant network. If each of those updates was an\n(on-chain) Task, the SFFL would most likely not be feasible in terms of\noperation cost and would also suffer a great blow in terms of a ",(0,t.jsx)(n.em,{children:"faster"}),"\nfinality."]}),"\n",(0,t.jsxs)(n.p,{children:["With this, the notion of a ",(0,t.jsx)(n.em,{children:"Message"})," was defined, as it then enables high\nthroughput and most importantly essentially off-chain operations. However, it's\nstill necessary to formalize an on-chain unit of work - not only so the AVS\nprogress is available on-chain but also to allow for fair slashing and payment\ndesigns."]}),"\n",(0,t.jsx)(n.h2,{id:"checkpoint-task",children:"Checkpoint Task"}),"\n",(0,t.jsxs)(n.p,{children:["In order to allow for the implementation of slashing and payment processes, the\nAVS Task was defined as a ",(0,t.jsx)(n.em,{children:"Checkpoint"})," Task."]}),"\n",(0,t.jsxs)(n.p,{children:["A Checkpoint Task is actually comprised of the submission of the merkleization\nof the ",(0,t.jsx)(n.em,{children:"Message"})," messaging on-chain for a time period. This Task, required from\ntime to time, not only provides a safe ledger to the AVS state, but also allows\nfor establishing slashing and payment processes without affecting the AVS cost\nof operation and speed significantly."]}),"\n",(0,t.jsxs)(n.p,{children:["This way, e.g. daily, the operators must then agree on all the Messages sent\nin that time period and aggregate them into an\n",(0,t.jsx)(n.a,{href:"https://docs.iden3.io/publications/pdfs/Merkle-Tree.pdf",children:"SMT (Sparse Merkle Tree)"}),".\nAnyone that has a copy of this SMT, which can be reconstructed from indexing\nthe Messages, could then generate proofs of membership and non-membership for\nany Message. This way, any Message that should've been attested can be verified\nand any message that shouldn't have been attested can also be verified -\nleading to both punishments and also liveness tracking."]}),"\n",(0,t.jsx)(n.h2,{id:"sffl-messages",children:"SFFL Messages"}),"\n",(0,t.jsx)(n.p,{children:"There are two Messages in SFFL:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"StateRootUpdateMessage"}),": A state root update Message attests to the state\nroot of a network in a specific block height and timestamp."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"library StateRootUpdate {\n    struct Message {\n        uint32 rollupId;\n        uint64 blockHeight;\n        uint64 timestamp;\n        bytes32 stateRoot;\n    }\n\n    // ...\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"OperatorSetUpdateMessage"}),": An operator set update message attests to an AVS\noperator set delta on Ethereum in a specific timestamp. All operator set\nupdates in a block are aggregated and attributed an autoincrementing ID, and\ninclude all the operators that had their weights changed."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"library OperatorSetUpdate {\n    struct Message {\n        uint64 id;\n        uint64 timestamp;\n        Operators.Operator[] operators;\n    }\n\n    // ...\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(6540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);